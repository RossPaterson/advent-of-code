module Main where

import Utilities
import Parser
import Control.Applicative
import Control.Monad
import Data.Map (Map, (!))
import qualified Data.Map as Map

-- Input processing

type Input = (Grammar Int Letter, [[Letter]])

-- grammar in restricted version of Chomsky normal form
type Grammar n t = Map n (Rule n t)
data Rule n t = Single t | Expansions [[n]]
    deriving Show
type Letter = Char

parse :: String -> Input
parse s = (parseGrammar p1, lines p2)
  where
    [p1, p2] = paragraphs s

parseGrammar :: String -> Grammar Int Letter
parseGrammar = Map.fromList . map (runParser production) . lines
  where
    production = (,) <$> nat <* string ": " <*> rule
    rule =
        Single <$ char '"' <*> letter <* char '"' <|>
        Expansions <$> sepBy1 (sepBy1 nat space) (string " | ")

-- Part One

{-
The example and supplied grammars have several nice properties:
* They are finite.
* They are unambiguous.
* All the strings generated by a nonterminal have the same length.
-}

-- All the strings generated by a nonterminal
-- (for exploration purposes; not required to solve the puzzle)
expand :: Ord n => Grammar n t -> n -> [[t]]
expand grammar n = case grammar!n of
    Single t -> [[t]]
    Expansions rhss -> concatMap (foldr add [[]]) rhss
  where
    add n' ss = [front ++ rest | front <- expand grammar n', rest <- ss]

-- match a prefix against the non-terminal, returning the list of residues
-- after each match
match :: (Ord n, Eq t) => Grammar n t -> n -> [t] -> [[t]]
match grammar n ts = case grammar!n of
    Single t
      | take 1 ts == [t] -> [drop 1 ts]
      | otherwise -> []
    Expansions rhss -> concat (map (foldM (flip (match grammar)) ts) rhss)

-- the nonterminal matches the whole string
matchAll :: (Ord n, Eq t) => Grammar n t -> n -> [t] -> Bool
matchAll grammar start ts = elem [] (match grammar start ts)

solve1 :: Input -> Int
solve1 (grammar, ss) = length $ filter (matchAll grammar 0) ss

testInput :: String
testInput = "\
    \0: 1 2\n\
    \1: \"a\"\n\
    \2: 1 3 | 3 1\n\
    \3: \"b\"\n"

testInput1 :: String
testInput1 = "\
    \0: 4 1 5\n\
    \1: 2 3 | 3 2\n\
    \2: 4 4 | 5 5\n\
    \3: 4 5 | 5 4\n\
    \4: \"a\"\n\
    \5: \"b\"\n\
    \\n\
    \ababbb\n\
    \bababa\n\
    \abbbab\n\
    \aaabbb\n\
    \aaaabbb\n"

tests1 :: [(String, Int)]
tests1 = [(testInput1, 2)]

-- Part Two

{-
The grammar is modified with replacementdefinitions:

8: 42 | 42 8
11: 42 31 | 42 11 31

The only occurrences of rules 8 and 11 are in the start rule:

0: 8 11

Therefore, R0 = R42^n R31^m where n > m > 0

In the input, R42 and R31 are both of length 8.

This grammar is no longer finite, but it is still unambiguous, and it is
not left recursive.  So the simple matcher still works.
-}

solve2 :: Input -> Int
solve2 (grammar, ss) = length $ filter (matchAll grammar' 0) ss
  where
    grammar' =
        Map.insert 8 (Expansions [[42], [42, 8]]) $
        Map.insert 11 (Expansions [[42, 31], [42, 11, 31]]) $
        grammar

testInput2 :: String
testInput2 = "\
    \42: 9 14 | 10 1\n\
    \9: 14 27 | 1 26\n\
    \10: 23 14 | 28 1\n\
    \1: \"a\"\n\
    \11: 42 31\n\
    \5: 1 14 | 15 1\n\
    \19: 14 1 | 14 14\n\
    \12: 24 14 | 19 1\n\
    \16: 15 1 | 14 14\n\
    \31: 14 17 | 1 13\n\
    \6: 14 14 | 1 14\n\
    \2: 1 24 | 14 4\n\
    \0: 8 11\n\
    \13: 14 3 | 1 12\n\
    \15: 1 | 14\n\
    \17: 14 2 | 1 7\n\
    \23: 25 1 | 22 14\n\
    \28: 16 1\n\
    \4: 1 1\n\
    \20: 14 14 | 1 15\n\
    \3: 5 14 | 16 1\n\
    \27: 1 6 | 14 18\n\
    \14: \"b\"\n\
    \21: 14 1 | 1 14\n\
    \25: 1 1 | 1 14\n\
    \22: 14 14\n\
    \8: 42\n\
    \26: 14 22 | 1 20\n\
    \18: 15 15\n\
    \7: 14 5 | 1 21\n\
    \24: 14 1\n\
    \\n\
    \abbbbbabbbaaaababbaabbbbabababbbabbbbbbabaaaa\n\
    \bbabbbbaabaabba\n\
    \babbbbaabbbbbabbbbbbaabaaabaaa\n\
    \aaabbbbbbaaaabaababaabababbabaaabbababababaaa\n\
    \bbbbbbbaaaabbbbaaabbabaaa\n\
    \bbbababbbbaaaaaaaabbababaaababaabab\n\
    \ababaaaaaabaaab\n\
    \ababaaaaabbbaba\n\
    \baabbaaaabbaaaababbaababb\n\
    \abbbbabbbbaaaababbbbbbaaaababb\n\
    \aaaaabbaabaaaaababaa\n\
    \aaaabbaaaabbaaa\n\
    \aaaabbaabbaaaaaaabbbabbbaaabbaabaaa\n\
    \babaaabbbaaabaababbaabababaaab\n\
    \aabbbbbaabbbaaaaaabbbbbababaaaaabbaaabba\n"

tests2 :: [(String, Int)]
tests2 = [(testInput2, 12)]

main :: IO ()
main = do
    s <- readFile "input/19.txt"
    let input = parse s
    putStr (unlines (failures "solve1" (solve1 . parse) tests1))
    print (solve1 input)
    putStr (unlines (failures "solve2" (solve2 . parse) tests2))
    print (solve2 input)
