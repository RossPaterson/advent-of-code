# Notes on each day's solutions

![Completion times 2015](https://raw.githubusercontent.com/jwoLondon/adventOfCode/master/images/completionTimes2015.png)

(image by [Jo Wood](https://github.com/jwoLondon))

I did this set retrospectively, after first participating in 2016.

Days 4, 5, 14 and 17 used MD5 hashing, exploiting the fact that
it is a bit costly to compute and is difficult to invert.  In 2017,
a custom hashing function with the same properties is used instead.

## [Day 1: Not Quite Lisp](https://adventofcode.com/2015/day/1)

An easy puzzle, with a common theme: part 1 was a fold, while part 2
involves the list generated by `scanl` on the same function.
(The leaderboard graph is misleading for this one; on the opening day,
it clearly took a few hours for word of the contest to spread.)

## [Day 2: I Was Told There Would Be No Math](https://adventofcode.com/2015/day/2)

More easy mapping and summing, with different functions in each part.

## [Day 3: Perfectly Spherical Houses in a Vacuum](https://adventofcode.com/2015/day/3)

The first part is a `scanl`.  The second is similar, once we've split the
list of moves in two.

## [Day 4: The Ideal Stocking Stuffer](https://adventofcode.com/2015/day/4)

Apart from finding an implementation of MD5 hashing, this was a pair of
trivial list searches.

## [Day 5: Doesn't He Have Intern-Elves For This?](https://adventofcode.com/2015/day/5)

More list processing: easy apart from following detailed instructions
precisely.

## [Day 6: Probably a Fire Hazard](https://adventofcode.com/2015/day/6)

Implementing a sequence of instructions to modify a grid.
The second part is a minor modification.

## [Day 7: Some Assembly Required](https://adventofcode.com/2015/day/7)

The first example of another AoC staple, assembly language, though here
just an acyclic dataflow graph.  The second part is a minor extension.

## [Day 8: Matchsticks](https://adventofcode.com/2015/day/8)

Decoding and encoding escape characters: more list processing, with a
few fiddly cases.

## [Day 9: All in a Single Night](https://adventofcode.com/2015/day/9)

This is a neat application for the list libraries, using `zip` to group
adjacent elements.  With the decomposed solution, part 2 was trivial.

## [Day 10: Elves Look, Elves Say](https://adventofcode.com/2015/day/10)

Conway's [look-and-say sequence](https://en.wikipedia.org/wiki/Look-and-say_sequence):
more list manipulation.  The second part is a trivial variation.

## [Day 11: Corporate Policy](https://adventofcode.com/2015/day/11)

A simple generate-and test password search.  Getting the second password
is trivial with the filter approach.

## [Day 12: JSAbacusFramework.io](https://adventofcode.com/2015/day/12)

Queries on a subset of JSON.  The first part doesn't require parsing,
and the second can be done with partial parsing, but it's cleaner to
knock up a parser for the subset used here.

## [Day 13: Knights of the Dinner Table](https://adventofcode.com/2015/day/13)

This is an exhaustive search of permutations to maximize a function.
The second part is a trivial variation.

## [Day 14: Reindeer Olympics](https://adventofcode.com/2015/day/14)

This is a fairly simple numeric calculation, with some care needed in
handling the gaps.  The second part takes a different view.

## [Day 15: Science for Hungry People](https://adventofcode.com/2015/day/15)

This is a form of multi-dimensional
[knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem).
The instance is small enough to handle with exhaustive search, once we
have written a function to generate all possible selections.
The second part imposes an additional constraint, which is easily
accommodated since we have separated generation and testing.

## [Day 16: Aunt Sue](https://adventofcode.com/2015/day/16)

The first part is simple record matching.  The second is only slightly
more elaborate.

## [Day 17: No Such Thing as Too Much](https://adventofcode.com/2015/day/17)

Both parts involve counting combinations satisfying certain criteria,
and can be handled with exhaustive search.

## [Day 18: Like a GIF For Your Yard](https://adventofcode.com/2015/day/18)

[Conway's Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life),
with a small variation in the second part.

## [Day 19: Medicine for Rudolph](https://adventofcode.com/2015/day/19)

After a lot of simple problems, we have something much more complex.
The input is an ambiguous context-free grammar (but with no terminals),
and a long string of symbols.  After comparing single derivation steps in
the first part, we are asked for the length of the shortest derivation
of a long string.  Exhaustive search seems impossibly costly, but on
examination the supplied grammar has a particular structure for which
a simple calculation suffices.

## [Day 20: Infinite Elves and Infinite Houses](https://adventofcode.com/2015/day/20)

The naive approach to the first part is too slow, so we need a little
elementary number theory.  However, brute force works fine on the
second part.

## [Day 21: RPG Simulator 20XX](https://adventofcode.com/2015/day/21)

The main task is to simulate a turn-based game combat system, and then
evaluate all possible purchases.  The second part is a minor variant.

## [Day 22: Wizard Simulator 20XX](https://adventofcode.com/2015/day/22)

This is a more elaborate version of the game from the previous day, with
a choice of actions at each turn, so after a bit of implementation work
it boils down to a shortest-path calculation.  The second part is a
trivial variation.

## [Day 23: Opening the Turing Lock](https://adventofcode.com/2015/day/23)

The task is to implement and run a simple virtual machine.  The second
part is a trivial variation, and runs faster than the first part, the
opposite of other similar exercises.

## [Day 24: It Hangs in the Balance](https://adventofcode.com/2015/day/24)

This is a bin-packing optimization problem, with some fiddly constraints,
but exhaustive search is sufficient.  The second part is a slightly
larger variant, but still feasible.

## [Day 25: Let It Snow](https://adventofcode.com/2015/day/25)

The task is a diagonal enumeration to get an index, and then applying a
[linear congruential generator](https://en.wikipedia.org/wiki/Linear_congruential_generator)
that many times.  The count is small enough that simple repetition is
feasible (cf 2019 day 22).
